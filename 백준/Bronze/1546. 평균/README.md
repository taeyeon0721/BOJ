# [Bronze I] 평균 - 1546 

[문제 링크](https://www.acmicpc.net/problem/1546) 

### 성능 요약

메모리: 18684 KB, 시간: 252 ms

### 제출 일자

2024년 5월 30일 17:05:56

-------------------------- ------------------------------
### 풀이 핵심
1. float/double형 사용★<br>
   - 오차범위가 있기 때문에 반드시 연산 할 때<br>
     최소한 자료형 1개 이상은 실수형으로 써야한다.<br>
     (정답과의 상대/절대 오차는 10^-2이하 = 즉 0.01 까지 허용)<br>
     
   - 그럼 double/float의 차이는 뭘까?<br>
     
      - 바이트 수<br>
        -> float: 4byte, double: 8byte
      - 유효자리수 표현<br>
        -> float: 7자리, double: 15~16자리<br>
        -> 유효자리수 up, 정밀도 up<br>
        => 고로 더 높은 정밀도가 필요할 땐 double을 사용해야함<br>

2. 배열을 사용해서 풀 수도/사용하지 않아서 풀 수도 있다.
   - 배열 사용x: max값 비교 / 배열 사용o: arrays.sort() 
   - 내 처음 풀이에서는 배열도 사용하고, max값 비교도 했다. 무슨말이냐...<br>
     -> max라는 변수를 사용해서 입력값이 들어올때마다 최대값을 비교해 주었다.<br>
        하지만 이렇게 하면 max값이 계속 초기화 되기 때문에 평균을 구하는 데 필요한 점수값을<br>
        저장할 수 없다고 생각했다. 그래서 max값 비교전에 배열에 일일이 입력된 값을 담아줬다. 이렇게.. <br>

           for(int i=0; i<N; i++) {
             int grade = sc.nextInt();
             arr[i] = grade;    //배열에 값 담고
             if(grade > max) {  //비교도 해서 max값 추리고 
              max = grade ;
             }			
            }
     - 그런데 여기서 if문을 사용해서 최대값을 구하지 않아도,<br>
       ★Arrays.sort()를 사용하여 배열에서의 최대값을 쉽게 구할 수 있다.<br>
     - 아니면 배열을 굳이 사용하지 않을 수도 있다!!!<br>
       여기서 아주 기초적인 수학 연산을 간과했는데<br>
        => 예를 들어 1,2,3,4 라는 값을 입력받았을때<Br>
           ★(1/m)*100 + (2/m)*100 + (3/m)*100 + (4/m)*100 이렇게 하나<br> 
           ★((1+2+3+4) / m)*100 을 하나 값은 같기 때문에<br> 
        => 배열에 값을 담을 담을 필요가 없고 누적산을 먼저 시키면 된다!!!<br>
          ★즉, (누적산/m)*100 하면 된다는 뜻<br>

            for (int i = 0; i < N; i++) {
                int grade = sc.nextInt();  			
                if(grade > max) {
                 max = grade; //최대값 구하고
                }
                sum += grade; //누적산해서 점수들의 총합 구함
                }
            System.out.println(((sum / max) * 100.0) / N); //수학 연산 간소화
